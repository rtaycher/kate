This file is part of the KDE project

Copyright (c) 2005 by Dominik Haumann <dhdev@gmx.de>
Copyright (c) 2005 by Christoph Cullmann <cullmann@kde.org>

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;

/** @file Mainpage.dox
    @brief Mainpage of the KTextEditor Interface Documentation.
*/
/**
@mainpage The KTextEditor Interfaces.

@section intro Introduction
The KTextEditor interfaces - also called KTE interfaces - are a set of
well-defined interfaces that can be implemented by an application/library.
It is possible to substitute an editor component with another. The two
popular implementations right now are
 - the Kate Editor Component or in short Kate Part and
 - the yzis vim-like editor.

Overview
 - @ref kte_design
 - @ref kte_guidelines
 - @ref kte_interface_access

External documentation
 - @ref kte_port_to_kde4
 - @ref kte_embedding

<hr/>

@section kte_design General Design of the Core Interfaces
The core of the KTextEditor interfaces consists of several main interfaces:
- @p KTextEditor::Factory - The Factory is an interface for the factory of
  any KTextEditor part and provides access to the editor object of this part.
- @p KTextEditor::Editor - The Editor interface describes the interface for
  for the editor part and provides methods to create documents, get a
  document list and a signal that informs about when a new document was
  created.
- @p KTextEditor::Document - The Document interface represents a document
  itself and allows to create views and access the document contents.
- @p KTextEditor::View - The View interface provides a widget to view the
  contents of a Document.

So the hierarchy looks as follows
\image html ktexteditorhierarchy.png "Basic KTextEditor Hierarchy"

The Factory provides access to the chosen Editor (selected with
@p KTextEditor::EditorChooser). The Editor has a list of all opened documents
and can create new documents. A Document's content is visualized by a View.
A Document can have multiple views (or none) and all views of the same
document are synchronized.

So a KTextEditor implementation provides access to its Factory in its library.
Via this Factory the Editor instance can be accessed (the actually underlying
Editor part) which gives access to the global services of the part.
If you want to load a Kate Part and a yzis part you need two different
factories. This is also the reason why the signal
<code>void Editor::documentCreated()</code> contains the Editor as first
argument. In other words: You would never want to have two factories around
(i.e. two Editor* instances) that both return Kate Parts, the Kate Part
solves this by using a static accessor in the Editor derived class KateGlobal
that returns the Editor* object.

@section kte_guidelines Coding Guidelines and API Conventions
The whole KTextEditor interfaces have a consistent design.
- naming should follow Qt style. Do not use Java style getters like getBla()
  for example,
- core interfaces (described above) which inherit QObject must declare all
  signals as real signals,
- all other interfaces, which do not subclass QObject, must declare their
  signals as virtual private member functions. An implementation must
  reimplement this virtual member function as a real signal.
- all signals must have the sender object as first parameter, for example
  all document signals should look like this:
  @code
  void signalFromDocument (KTextEditor::Document *doc, .....);
  @endcode
  This allows easy and consistent query which object did send the signal,
  which is important for most applications, as they listen to multiple
  documents/views/editors/...
- all interface functions should be virtual, to allow subclasses to
  overwrite them, most members should even be pure virtual, beside
  additional convenience/helper functions.

The interface @p KTextEditor::Cursor represents a cursorposition, i.e. a
line/column tuple. The same holds for @p KTextEditor::Range. As both of this
concepts are much cleaner than tuples, please keep the following guidelines:
- never use line/column tuples in parameter lists, use
  @p KTextEditor::Cursor instead,
- never use Cursor/Cursor tuples for ranges, use a @p KTextEditor::Range
  instead of two Cursors.

@section kte_interface_access Accessing an Interface
To access an extension interface qobject_cast should be used (see also
http://doc.trolltech.com/4.0/plugins-howto.html#the-lower-level-api-extending-qt-applications
for how qobject_cast works with Q_INTERFACES and Q_DECLARE_INTERFACE).

A KTextEditor implementation may implement interfaces, but it does not @e need
to. So as a KTextEditor user you have to cast the Document or View into the
interface and then check whether the cast returns NULL or the desired
interface.

To cast a Document @e doc into the @e DesiredExtensionInterface do the
following:
@code
  // doc is of type KTextEditor::Document*
  KTextEditor::DesiredExtensionInterface *iface =
      qobject_cast<KTextEditor::DesiredExtensionInterface*>( doc );

  if( iface ) {
      // the implementation supports the interface
      // do stuff
}
@endcode

To cast a View @e view into the @e DesiredExtensionInterface do the following:
@code
  // view is of type KTextEditor::View*
  KTextEditor::DesiredExtensionInterface *iface =
      qobject_cast<KTextEditor::DesiredExtensionInterface*>( view );

  if( iface ) {
      // the implementation supports the interface
      // do stuff
}
@endcode

@author Dominik Haumann \<dhdev@gmx.de\>
@author Christoph Cullmann \<cullmann@kde.org\>
*/





/**
@page kte_port_to_kde4 Porting to KDE 4
This document describes porting applications using the KTextEditor interfaces
from KDE 3 to KDE 4.

\section kte_port_intro Introduction
The KTextEditor interfaces changes in KDE 4 are neither binary nor source
compatible to the KTextEditor interfaces included in KDE 3, so programs
written/compiled for the KDE 3 KTextEditor interfaces will not compile with
KDE 4.

The KDE 4 KTextEditor interfaces undergone a heavy cleanup, i.e. obsolete
functions were removed, interfaces were merged and extended. All interface
changes like for example parameter changes of a function are not mentioned in
detail in this page, look into the particular class API documentation. As
already mentioned in the mainpage, all line/column tuples were replaced with a
Cursor, and all Cursor/Cursor tuples with a Range.

@section kte_port_change Interface Changes
Entirely removed interfaces are, in order:
 - all DCOP interfaces
 - @p ClipboardInterface
 - @p CursorInterface
 - @p DynWordWrapInterface
 - @p PrintInterface
 - @p SelectionExtDCOPInterface
 - @p UndoInterface
 - @p ViewStatusMsgInterface
 - @p WordWrapInterface

@section kte_port_merge Merged Interfaces
The following interfaces were merged, in order:
 - @p BlockSelectionInterface, @p SelectionInterface and
   @p SelectionInterfaceExt were merged into the @p View, so that a
   @p Document alone does not provide any selection methods anymore.
 - @p DocumentInfoInterface was merged into the @p Document
 - @p EditInterface was merged into the @p Document
 - @p EditInterfaceExt was merged into the @p Document
 - @p EncodingInterface was merged into the @p Document
 - @p MarkInterfaceExtension was merged into the @p MarkInterface
 - @p PluginViewInterface was merged into the @p Plugin
 - @p PopupMenuInterface was merged into the @p View
 - @p ViewCursorInterface was merged into the @p View

@section kte_port_rename Interface Changes
The following interfaces were renamed, in order:
 - @p CompletionEntry was renamed to @p CompletionItem
 - signal @p modifiedOnDisc() was renamed to @p modifiedOnDisk()

@section kte_port_new New Interfaces
@todo new interfaces...

@section kte_port_plugins Plugin Changes
The Plugin interface changed to support more than only one Document at a time.
A plugin in a KDE 4 KTextEditor implementation no longer is bound to a single
document (i.e. for @e every document a single instance of the plugin existed).
Now a plugin can handle several documents and views.

@see KTextEditor::Plugin

@author Dominik Haumann \<dhdev@gmx.de\>
*/





/**
@page kte_embedding Embedding a KTextEditor Component into an Application

@todo everything

Actually KWrite is THE example... just convert it into a howto.
link: -lktexteditor hint or \$(LIB_KTEXTEDITOR) in the KDE build framework.
<pre>
<code>
 __________________________________
 |This page is under construction!|
 ----------------------------------
       \   ^__^
        \  (Oo)\_______
           (__)\       )\/\
               ||----w |
               ||     ||
</code>
</pre>

@author Dominik Haumann \<dhdev@gmx.de\>
*/
