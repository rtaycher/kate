This file is part of the KDE project

Copyright (c) 2005 by Dominik Haumann <dhdev@gmx.de>
Copyright (c) 2005 by Christoph Cullmann <cullmann@kde.org>

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;

/** @file Mainpage.dox
    @brief Mainpage of the KTextEditor Interface Documentation.
*/
/**
@mainpage The KTextEditor Interfaces.

@section intro Introduction
The KTextEditor interfaces - also called KTE interfaces - are a set of
well-defined interfaces that can be implemented by an application/library.
It is possible to substitute an editor component with another. The two
popular implementations right now are
 - the Kate Editor Component or in short Kate Part and
 - the yzis vim-like editor.

Overview
 - @ref kte_design
 - @ref kte_guidelines
 - @ref kte_porting_to_kde4
 - @ref kte_embedding

@section kte_design General Design of the Core Interfaces
The core of the KTextEditor interfaces consists of several main interfaces:
- @p KTextEditor::Factory - The Factory is an interface for the factory of
  any KTextEditor part and provides access to the editor object of this part.
- @p KTextEditor::Editor - The Editor interface describes the interface for
  for the editor part and provides methods to create documents, get a
  document list and a signal that informs about when a new document was
  created.
- @p KTextEditor::Document - The Document interface represents a document
  itself and allows to create views and access the document contents.
- @p KTextEditor::View - The View interface provides a widget to view the
  contents of a Document.

So the hierarchy looks as follows
\image html ktexteditorhierarchy.png "Basic KTextEditor Hierarchy"

The Factory provides access to the chosen Editor (selected with
@p KTextEditor::EditorChooser). The Editor has a list of all opened documents
and can create new documents. A Document's content is visualized by a View.
A Document can have multiple views (or none) and all views of the same
document are synchronized.

So a KTextEditor implementation provides access to its Factory in its library.
Via this Factory the Editor instance can be accessed (the actually underlying
Editor part) which gives access to the global services of the part.
If you want to load a Kate Part and a yzis part you need two different
factories. This is also the reason why the signal
<code>void Editor::documentCreated()</code> contains the Editor as first
argument. In other words: You would never want to have two factories around
(i.e. two Editor* instances) that both return Kate Parts, the Kate Part
solves this by using a static accessor in the Editor derived class KateGlobal
that returns the Editor* object.

@section kte_guidelines Coding Guidelines and API Conventions
The whole KTextEditor interfaces have a consistent design.
- naming should follow Qt style. Do not use Java style getters like getBla()
  for example,
- core interfaces (described above) which inherit QObject must declare all
  signals as real signals,
- all other interfaces, which do not subclass QObject, must declare their
  signals as virtual private member functions. An implementation must
  reimplement this virtual member function as a real signal.
- all signals must have the sender object as first parameter, for example
  all document signals should look like this:
  @code
  void signalFromDocument (KTextEditor::Document *doc, .....);
  @endcode
  This allows easy and consistent query which object did send the signal,
  which is important for most applications, as they listen to multiple
  documents/views/editors/...
- all interface functions should be virtual, to allow subclasses to
  overwrite them, most members should even be pure virtual, beside
  additional convenience/helper functions.

The interface @p KTextEditor::Cursor represents a cursorposition, i.e. a
line/column tuple. The same holds for @p KTextEditor::Range. As both of this
concepts are much cleaner than tuples, please keep the following guidelines:
- never use line/column tuples in parameter lists, use
  @p KTextEditor::Cursor instead,
- never use Cursor/Cursor tuples for ranges, use a @p KTextEditor::Range
  instead of two Cursors.



@todo add
 - @a -lktexteditor hint or $(LIB_KTEXTEDITOR) in the KDE build framework.
 - Implementor Notes: Information about Q_INTERFACES and qobject_cast.



@author Dominik Haumann \<dhdev@gmx.de\>
@author Christoph Cullmann \<cullmann@kde.org\>
*/





/**
@page kte_porting_to_kde4 Porting to KDE 4
@author Dominik Haumann \<dhdev@gmx.de\>
*/





/**
@page kte_embedding Embedding a KTextEditor Component into an Application
@author Dominik Haumann \<dhdev@gmx.de\>
*/
