From 089c434972069b38d5587415c5a0fadc7863d4b4 Mon Sep 17 00:00:00 2001
From: Erlend Hamberg <ehamberg@gmail.com>
Date: Mon, 15 Jun 2009 23:47:23 +0200
Subject: [PATCH] the first "preparation for visual block mode" commit

the concept of a visual block mode is introduced, but no commands support
it yet. The two major changes are:
* VisualBlockMode has been added to the ViMode enum and methods for
changing to/from this new mode has been added
* visual mode highlighting has been moved to katerenderer. no more smart
range attribute hacks!
---
 render/katerenderer.cpp           |   42 ++++++++++++++++-
 utils/katevimodebar.cpp           |    3 +
 view/kateviewinternal.cpp         |    2 +-
 vimode/kateviinputmodemanager.cpp |   22 +++++---
 vimode/kateviinputmodemanager.h   |    6 +-
 vimode/katevimodebase.cpp         |   22 ++++++++-
 vimode/katevimodebase.h           |    4 +-
 vimode/katevinormalmode.cpp       |   19 ++++++-
 vimode/katevinormalmode.h         |    4 +-
 vimode/katevivisualmode.cpp       |   96 ++++++++++++++++++++++--------------
 vimode/katevivisualmode.h         |   15 ++++--
 11 files changed, 172 insertions(+), 63 deletions(-)

diff --git a/render/katerenderer.cpp b/render/katerenderer.cpp
index 42a5eef..58bb7ac 100644
--- a/render/katerenderer.cpp
+++ b/render/katerenderer.cpp
@@ -29,6 +29,8 @@
 #include "katerenderrange.h"
 #include "katetextlayout.h"
 
+#include "katevivisualmode.h"
+
 #include <limits.h>
 
 #include <kdebug.h>
@@ -331,10 +333,36 @@ QList<QTextLayout::FormatRange> KateRenderer::decorationsForLine( const KateText
       else
         if(m_view->blockSelection() && m_view->selectionRange().overlapsLine(line))
           selectionHighlight->addRange(new KTextEditor::Range(line, m_view->selectionRange().start().column(), line, m_view->selectionRange().end().column()), backgroundAttribute);
-        else
+        else {
           selectionHighlight->addRange(new KTextEditor::Range(m_view->selectionRange()), backgroundAttribute);
+          kDebug( 13070 ) << m_view->selectionRange() << " SEL RANGE";
+        }
 
       renderRanges.append(selectionHighlight);
+    // hihglighting for the vi visual modes
+    } else if ( m_view->getViInputModeManager()->getCurrentViMode() == VisualMode
+             || m_view->getViInputModeManager()->getCurrentViMode() == VisualLineMode
+             || m_view->getViInputModeManager()->getCurrentViMode() == VisualBlockMode ) {
+
+      KTextEditor::Range r = m_view->getViInputModeManager()->getViVisualMode()->getVisualRange();
+
+      if ( r.isValid() && (r.end().line() == line || r.start().line() == line || r.containsLine( line ) )) {
+        NormalRenderRange* selectionHighlight = new NormalRenderRange();
+        static KTextEditor::Attribute::Ptr backgroundAttribute;
+        if (!backgroundAttribute)
+          backgroundAttribute = KTextEditor::Attribute::Ptr(new KTextEditor::Attribute());
+
+        backgroundAttribute->setBackground(config()->selectionColor());
+
+        if ( m_view->getViInputModeManager()->getCurrentViMode() == VisualBlockMode ) {
+          selectionHighlight->addRange(new KTextEditor::Range(line, r.start().column(), line, r.end().column()+1), backgroundAttribute);
+        } else if ( m_view->getViInputModeManager()->getCurrentViMode() == VisualLineMode ) {
+          selectionHighlight->addRange(new KTextEditor::Range(line, 0, line, m_view->doc()->lineLength( line )), backgroundAttribute);
+        } else {
+          selectionHighlight->addRange(new KTextEditor::Range(r), backgroundAttribute);
+        }
+        renderRanges.append(selectionHighlight);
+      }
     }
 
     KTextEditor::Cursor currentPosition, endPosition;
@@ -398,6 +426,18 @@ QList<QTextLayout::FormatRange> KateRenderer::decorationsForLine( const KateText
           } else if (m_view->selection() && m_view->selectionRange().contains(currentPosition)) {
             assignSelectionBrushesFromAttribute(fr, *a);
           }
+        } else if ( m_view->getCurrentViMode() == VisualMode || m_view->getCurrentViMode() == VisualLineMode ) {
+          if (m_view->getViInputModeManager()->getViVisualMode()->getVisualRange().contains(currentPosition)) {
+            assignSelectionBrushesFromAttribute(fr, *a);
+          }
+        } else if ( m_view->getCurrentViMode() == VisualBlockMode ) {
+          if (m_view->getViInputModeManager()->getViVisualMode()->getVisualRange().contains(currentPosition)) {
+            int c1 = m_view->getViInputModeManager()->getViVisualMode()->getVisualRange().start().column();
+            int c2 = m_view->getViInputModeManager()->getViVisualMode()->getVisualRange().end().column();
+
+            if(currentPosition.column() >= c1 && currentPosition.column() < c2)
+              assignSelectionBrushesFromAttribute(fr, *a);
+          }
         }
       }
 
diff --git a/utils/katevimodebar.cpp b/utils/katevimodebar.cpp
index 45813ff..aceff0c 100644
--- a/utils/katevimodebar.cpp
+++ b/utils/katevimodebar.cpp
@@ -119,6 +119,9 @@ QString KateViModeBar::modeToString(ViMode mode) const
     case VisualMode:
       modeStr = i18n("VI: VISUAL");
       break;
+    case VisualBlockMode:
+      modeStr = i18n("VI: VISUAL BLOCK");
+      break;
     case VisualLineMode:
       modeStr = i18n("VI: VISUAL LINE");
       break;
diff --git a/view/kateviewinternal.cpp b/view/kateviewinternal.cpp
index a783dfd..5dac899 100644
--- a/view/kateviewinternal.cpp
+++ b/view/kateviewinternal.cpp
@@ -3629,7 +3629,7 @@ bool KateViewInternal::rangeAffectsView(const KTextEditor::Range& range) const
 {
   if(range.end().line() < m_startPos.line())
     return false;
-  if(range.start().line() > m_startPos.line() + m_visibleLineCount)
+  if((unsigned int)range.start().line() > m_startPos.line() + m_visibleLineCount)
     return false;
   
   return true;
diff --git a/vimode/kateviinputmodemanager.cpp b/vimode/kateviinputmodemanager.cpp
index d487110..f305a8b 100644
--- a/vimode/kateviinputmodemanager.cpp
+++ b/vimode/kateviinputmodemanager.cpp
@@ -1,5 +1,6 @@
 /* This file is part of the KDE libraries
- * Copyright (C) 2008 Erlend Hamberg <ehamberg@gmail.com>
+ * Copyright (C) 2008 - 2009 Erlend Hamberg <ehamberg@gmail.com>
+ * Copyright (C) 2009 Paul Gideon Dann <pdgiddie@gmail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -61,6 +62,8 @@ bool KateViInputModeManager::handleKeypress(const QKeyEvent *e)
     appendKeyEventToLog( copy );
   }
 
+  // FIXME: I this we're making things difficult for ourselves here.  Maybe some
+  //        more thought needs to go into the inheritance hierarchy.
   switch(m_currentViMode) {
   case NormalMode:
     res = m_viNormalMode->handleKeypress(e);
@@ -70,9 +73,11 @@ bool KateViInputModeManager::handleKeypress(const QKeyEvent *e)
     break;
   case VisualMode:
   case VisualLineMode:
+  case VisualBlockMode:
     res = m_viVisualMode->handleKeypress(e);
     break;
   default:
+    kDebug( 13070 ) << "WARNING: Unhandled keypress";
     res = false;
   }
 
@@ -227,16 +232,16 @@ void KateViInputModeManager::viEnterInsertMode()
   m_viewInternal->repaint ();
 }
 
-void KateViInputModeManager::viEnterVisualMode( bool visualLine )
+void KateViInputModeManager::viEnterVisualMode( ViMode mode )
 {
-  if ( !visualLine ) {
-    changeViMode(VisualMode);
-  } else {
-    changeViMode(VisualLineMode);
-  }
+  changeViMode( mode );
 
   m_viewInternal->repaint ();
-  getViVisualMode()->setVisualLine( visualLine );
+  if ( mode == VisualBlockMode ) {
+    getViVisualMode()->setVisualBlock( true );
+  } else if ( mode == VisualLineMode ) {
+    getViVisualMode()->setVisualLine( true );
+  }
   getViVisualMode()->init();
 }
 
@@ -268,6 +273,7 @@ const QString KateViInputModeManager::getVerbatimKeys() const
     break;
   case VisualMode:
   case VisualLineMode:
+  case VisualBlockMode:
     cmd = m_viVisualMode->getVerbatimKeys();
     break;
   }
diff --git a/vimode/kateviinputmodemanager.h b/vimode/kateviinputmodemanager.h
index ee7003b..12b146a 100644
--- a/vimode/kateviinputmodemanager.h
+++ b/vimode/kateviinputmodemanager.h
@@ -38,7 +38,8 @@ enum ViMode {
   NormalMode,
   InsertMode,
   VisualMode,
-  VisualLineMode
+  VisualLineMode,
+  VisualBlockMode
 };
 
 class KateViInputModeManager
@@ -82,9 +83,8 @@ public:
 
   /**
    * set visual mode to be the active vi mode and make the needed setup work
-   * if visualLine is true, visual linewise mode is started
    */
-  void viEnterVisualMode(bool visualLine = false);
+  void viEnterVisualMode( ViMode visualMode = VisualMode );
 
   /**
    * @return the KateViNormalMode instance
diff --git a/vimode/katevimodebase.cpp b/vimode/katevimodebase.cpp
index 9f1173d..81a1256 100644
--- a/vimode/katevimodebase.cpp
+++ b/vimode/katevimodebase.cpp
@@ -1,5 +1,6 @@
 /* This file is part of the KDE libraries
- * Copyright (C) 2008 Erlend Hamberg <ehamberg@gmail.com>
+ * Copyright (C) 2008 - 2009 Erlend Hamberg <ehamberg@gmail.com>
+ * Copyright (C) 2009 Paul Gideon Dann <pdgiddie@gmail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -697,6 +698,9 @@ bool KateViModeBase::startVisualMode()
   if ( m_view->getCurrentViMode() == VisualLineMode ) {
     m_viInputModeManager->getViVisualMode()->setVisualLine( false );
     m_viInputModeManager->changeViMode(VisualMode);
+  } else if (m_view->getCurrentViMode() == VisualBlockMode ) {
+    m_viInputModeManager->getViVisualMode()->setVisualBlock( false );
+    m_viInputModeManager->changeViMode(VisualMode);
   } else {
     m_viInputModeManager->viEnterVisualMode();
   }
@@ -706,13 +710,27 @@ bool KateViModeBase::startVisualMode()
   return true;
 }
 
+bool KateViModeBase::startVisualBlockMode()
+{
+  if ( m_view->getCurrentViMode() == VisualMode ) {
+    m_viInputModeManager->getViVisualMode()->setVisualBlock( true );
+    m_viInputModeManager->changeViMode(VisualBlockMode);
+  } else {
+    m_viInputModeManager->viEnterVisualMode( VisualBlockMode );
+  }
+
+  m_view->updateViModeBarMode();
+
+  return true;
+}
+
 bool KateViModeBase::startVisualLineMode()
 {
   if ( m_view->getCurrentViMode() == VisualMode ) {
     m_viInputModeManager->getViVisualMode()->setVisualLine( true );
     m_viInputModeManager->changeViMode(VisualLineMode);
   } else {
-    m_viInputModeManager->viEnterVisualMode( true );
+    m_viInputModeManager->viEnterVisualMode( VisualLineMode );
   }
 
   m_view->updateViModeBarMode();
diff --git a/vimode/katevimodebase.h b/vimode/katevimodebase.h
index 6b893b3..ec37e35 100644
--- a/vimode/katevimodebase.h
+++ b/vimode/katevimodebase.h
@@ -1,5 +1,6 @@
 /* This file is part of the KDE libraries
- * Copyright (C) 2008 Erlend Hamberg <ehamberg@gmail.com>
+ * Copyright (C) 2008 - 2009 Erlend Hamberg <ehamberg@gmail.com>
+ * Copyright (C) 2009 Paul Gideon Dann <pdgiddie@gmail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -81,6 +82,7 @@ class KateViModeBase : public QObject
     bool startInsertMode();
     bool startVisualMode();
     bool startVisualLineMode();
+    bool startVisualBlockMode();
 
     void error( const QString &errorMsg ) const;
     void message( const QString &msg ) const;
diff --git a/vimode/katevinormalmode.cpp b/vimode/katevinormalmode.cpp
index 0061f3c..1db81b8 100644
--- a/vimode/katevinormalmode.cpp
+++ b/vimode/katevinormalmode.cpp
@@ -1,6 +1,7 @@
 /* This file is part of the KDE libraries
- * Copyright (C) 2008 Erlend Hamberg <ehamberg@gmail.com>
+ * Copyright (C) 2008 - 2009 Erlend Hamberg <ehamberg@gmail.com>
  * Copyright (C) 2008 Evgeniy Ivanov <powerfox@kde.ru>
+ * Copyright (C) 2009 Paul Gideon Dann <pdgiddie@gmail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -488,6 +489,16 @@ bool KateViNormalMode::commandEnterVisualLineMode()
   return startVisualLineMode();
 }
 
+bool KateViNormalMode::commandEnterVisualBlockMode()
+{
+  if ( m_viInputModeManager->getCurrentViMode() == VisualBlockMode ) {
+    reset();
+    return true;
+  }
+
+  return startVisualBlockMode();
+}
+
 bool KateViNormalMode::commandEnterVisualMode()
 {
   if ( m_viInputModeManager->getCurrentViMode() == VisualMode ) {
@@ -500,8 +511,9 @@ bool KateViNormalMode::commandEnterVisualMode()
 
 bool KateViNormalMode::commandToOtherEnd()
 {
-  if ( m_viInputModeManager->getCurrentViMode() == VisualLineMode
-      || m_viInputModeManager->getCurrentViMode() == VisualMode ) {
+  if ( m_viInputModeManager->getCurrentViMode() == VisualMode
+      || m_viInputModeManager->getCurrentViMode() == VisualLineMode
+      || m_viInputModeManager->getCurrentViMode() == VisualBlockMode ) {
     m_viInputModeManager->getViVisualMode()->switchStartEnd();
     return true;
   }
@@ -2104,6 +2116,7 @@ void KateViNormalMode::initializeCommands()
   m_commands.push_back( new KateViCommand( this, "I", &KateViNormalMode::commandEnterInsertModeBeforeFirstCharacterOfLine, IS_CHANGE ) );
   m_commands.push_back( new KateViCommand( this, "v", &KateViNormalMode::commandEnterVisualMode ) );
   m_commands.push_back( new KateViCommand( this, "V", &KateViNormalMode::commandEnterVisualLineMode ) );
+  m_commands.push_back( new KateViCommand( this, "<c-v>", &KateViNormalMode::commandEnterVisualBlockMode ) );
   m_commands.push_back( new KateViCommand( this, "o", &KateViNormalMode::commandOpenNewLineUnder, IS_CHANGE ) );
   m_commands.push_back( new KateViCommand( this, "O", &KateViNormalMode::commandOpenNewLineOver, IS_CHANGE ) );
   m_commands.push_back( new KateViCommand( this, "J", &KateViNormalMode::commandJoinLines, IS_CHANGE ) );
diff --git a/vimode/katevinormalmode.h b/vimode/katevinormalmode.h
index 7825d5c..f730ea4 100644
--- a/vimode/katevinormalmode.h
+++ b/vimode/katevinormalmode.h
@@ -1,5 +1,6 @@
 /* This file is part of the KDE libraries
- * Copyright (C) 2008 Erlend Hamberg <ehamberg@gmail.com>
+ * Copyright (C) 2008 - 2009 Erlend Hamberg <ehamberg@gmail.com>
+ * Copyright (C) 2009 Paul Gideon Dann <pdgiddie@gmail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -62,6 +63,7 @@ class KateViNormalMode : public KateViModeBase
 
     bool commandEnterVisualMode();
     bool commandEnterVisualLineMode();
+    bool commandEnterVisualBlockMode();
     bool commandToOtherEnd();
 
     bool commandDelete();
diff --git a/vimode/katevivisualmode.cpp b/vimode/katevivisualmode.cpp
index 956b594..57ad1fa 100644
--- a/vimode/katevivisualmode.cpp
+++ b/vimode/katevivisualmode.cpp
@@ -25,20 +25,10 @@ KateViVisualMode::KateViVisualMode( KateViInputModeManager* viInputModeManager,
   : KateViNormalMode( viInputModeManager, view, viewInternal )
 {
   m_start.setPosition( -1, -1 );
-  m_topRange = doc()->newSmartRange(doc()->documentRange());
-  static_cast<KateSmartRange*>(m_topRange)->setInternal();
-  m_topRange->setInsertBehavior(KTextEditor::SmartRange::ExpandLeft | KTextEditor::SmartRange::ExpandRight);
-
-  m_view->addInternalHighlight(m_topRange);
+  m_previous.setPosition( -1, -1 );
 
   m_visualLine = false;
-
-  KTextEditor::Range r;
-  highlightRange = doc()->newSmartRange( r, m_topRange );
-  attribute = KTextEditor::Attribute::Ptr(new KTextEditor::Attribute());
-  attribute->setBackground( m_viewInternal->palette().highlight() );
-  attribute->setForeground( m_viewInternal->palette().highlightedText() );
-  highlightRange->setInsertBehavior(KTextEditor::SmartRange::DoNotExpand);
+  m_visualBlock = false;
 
   initializeCommands();
 }
@@ -47,28 +37,35 @@ KateViVisualMode::~KateViVisualMode()
 {
 }
 
-void KateViVisualMode::highlight() const
+void KateViVisualMode::updateDirty( bool entireView ) const
 {
-  // FIXME: HACK to avoid highlight bug: remove highlighing and re-set it
-  highlightRange->setAttribute(KTextEditor::Attribute::Ptr());
-  highlightRange->setAttribute(attribute);
-
-  KTextEditor::Cursor c1 = m_start;
-  KTextEditor::Cursor c2 = m_view->cursorPosition();
-
-  if ( m_visualLine ) {
-      c1.setColumn( ( c1 < c2 ) ? 0 : getLine( m_start.line() ).length() );
-      c2.setColumn( ( c1 < c2  ? getLine().length() : 0 ) );
-  } else if ( c1 > c2 && c1.column() != 0 ) {
-    c1.setColumn( c1.column()+1 );
-  }
+  KTextEditor::Cursor c = m_view->cursorPosition();
 
-  highlightRange->setRange( KTextEditor::Range( c1, c2 ) );
+  if ( entireView ) {
+    m_view->tagLines(0, m_view->doc()->lastLine() );
+  } else {
+    // tag lines that might have changed their highlighting as dirty
+    if ( c.line() >= m_start.line() ) { // selection in the "normal" direction
+      if ( c.line() > m_previous.line() ) {
+        m_view->tagLines(m_previous.line(), m_view->cursorPosition().line());
+      } else {
+        m_view->tagLines(m_start.line(), m_previous.line());
+      }
+    } else { // selection in the "opposite" direction, i.e., upward or to the left
+      if ( c.line() < m_previous.line() ) {
+        m_view->tagLines(m_view->cursorPosition().line(), m_previous.line());
+      } else {
+        m_view->tagLines(m_previous.line(), m_start.line());
+      }
+    }
+  }
+  m_view->updateView( true );
 }
 
 void KateViVisualMode::goToPos( const KateViRange &r )
 {
   KTextEditor::Cursor c = m_view->cursorPosition();
+  m_previous = c;
 
   if ( r.startLine != -1 && r.startColumn != -1 && c == m_start ) {
     m_start.setLine( r.startLine );
@@ -94,32 +91,37 @@ void KateViVisualMode::goToPos( const KateViRange &r )
   m_commandRange.endLine = r.endLine;
   m_commandRange.endColumn = r.endColumn;
 
-  highlight();
+  updateDirty();
 }
 
 void KateViVisualMode::reset()
 {
-    // remove highlighting
-    highlightRange->setAttribute(KTextEditor::Attribute::Ptr());
-
     m_awaitingMotionOrTextObject.push_back( 0 ); // search for text objects/motion from char 0
 
     m_visualLine = false;
+    m_visualBlock = false;
 
     // only switch to normal mode if still in visual mode. commands like c, s, ...
     // can have switched to insert mode
     if ( m_viInputModeManager->getCurrentViMode() == VisualMode
-        || m_viInputModeManager->getCurrentViMode() == VisualLineMode ) {
+        || m_viInputModeManager->getCurrentViMode() == VisualLineMode
+        || m_viInputModeManager->getCurrentViMode() == VisualBlockMode ) {
       m_viInputModeManager->viEnterNormalMode();
     }
+
+    // TODO: set register < and > (see :help '< in vim)
+
+    m_start.setPosition( -1, -1 );
+    m_previous.setPosition( -1, -1 );
+
+    // remove highlighting
+    updateDirty( true );
 }
 
 void KateViVisualMode::init()
 {
     m_start = m_view->cursorPosition();
-    highlightRange->setRange( KTextEditor::Range( m_start, m_view->cursorPosition() ) );
-    highlightRange->setAttribute(attribute);
-    highlight();
+    updateDirty();
 
     m_awaitingMotionOrTextObject.push_back( 0 ); // search for text objects/motion from char 0
 
@@ -128,10 +130,16 @@ void KateViVisualMode::init()
 }
 
 
+void KateViVisualMode::setVisualBlock( bool l )
+{
+  m_visualBlock = l;
+  updateDirty();
+}
+
 void KateViVisualMode::setVisualLine( bool l )
 {
   m_visualLine = l;
-  highlight();
+  updateDirty();
 }
 
 void KateViVisualMode::switchStartEnd()
@@ -141,7 +149,21 @@ void KateViVisualMode::switchStartEnd()
 
   updateCursor( c );
 
-  highlight();
+  m_stickyColumn = -1;
+
+  updateDirty();
+}
+
+KTextEditor::Range KateViVisualMode::getVisualRange() const
+{
+  KTextEditor::Cursor c = m_view->cursorPosition();
+
+  int startCol = qMin( c.column(), m_start.column() );
+  int startLine = qMin( c.line(), m_start.line() );
+  int endCol = qMax( c.column(), m_start.column() );
+  int endLine = qMax( c.line(), m_start.line() );
+
+  return KTextEditor::Range( startLine, startCol, endLine, endCol );
 }
 
 void KateViVisualMode::initializeCommands()
diff --git a/vimode/katevivisualmode.h b/vimode/katevivisualmode.h
index 4c78030..b7a1418 100644
--- a/vimode/katevivisualmode.h
+++ b/vimode/katevivisualmode.h
@@ -1,5 +1,6 @@
 /* This file is part of the KDE libraries
- * Copyright (C) 2008 Erlend Hamberg <ehamberg@gmail.com>
+ * Copyright (C) 2008 - 2009 Erlend Hamberg <ehamberg@gmail.com>
+ * Copyright (C) 2009 Paul Gideon Dann <pdgiddie@gmail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -34,20 +35,22 @@ class KateViVisualMode : public KateViNormalMode {
     void init();
 
     void setVisualLine( bool l );
+    void setVisualBlock( bool l );
     bool isVisualLine() const { return m_visualLine; }
+    bool isVisualBlock() const { return m_visualBlock; }
     void switchStartEnd();
     KTextEditor::Cursor getStart() const { return m_start; }
+    KTextEditor::Range getVisualRange() const;
 
   private:
     void initializeCommands();
-    void highlight() const;
+    void updateDirty( bool entireView = false ) const;
     void goToPos( const KateViRange &r );
     void reset();
-    bool m_visualLine;
+    bool m_visualLine; // FIXME:
+    bool m_visualBlock;// use a ViMode variable instead
     KTextEditor::Cursor m_start;
-    KTextEditor::SmartRange * m_topRange;
-    KTextEditor::SmartRange * highlightRange;
-    KTextEditor::Attribute::Ptr attribute;
+    KTextEditor::Cursor m_previous; // previous position, used when deciding which lines to redraw
 };
 
 #endif
-- 
1.6.0.2

